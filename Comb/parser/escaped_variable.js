// Generated by CoffeeScript 1.4.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['comb/mustache'], function(Mustache) {
    'use strict';

    var EscapedVariable;
    return EscapedVariable = (function(_super) {

      __extends(EscapedVariable, _super);

      function EscapedVariable() {
        this.update = __bind(this.update, this);
        return EscapedVariable.__super__.constructor.apply(this, arguments);
      }

      EscapedVariable.prototype.initialize = function() {
        return EscapedVariable.__super__.initialize.apply(this, arguments);
      };

      EscapedVariable.prototype.parse = function() {
        var nextIndex, nextOffset, node, _ref;
        EscapedVariable.__super__.parse.apply(this, arguments);
        switch (this.prev.type) {
          case 'null':
          case 'section':
          case 'escaped':
          case 'text':
            break;
          case 'unescaped':
            throw new Error("Unsupported matching type");
            break;
          case 'node':
          case 'emptynode':
          case 'comment':
            this.nodeOffset += 1;
        }
        node = this.node();
        nextOffset = 0;
        if (node != null) {
          this.string = node.data.substring(this.strOffset);
          if (this.next.type === 'text') {
            nextIndex = this.string.indexOf(this.next.value);
            if (nextIndex === -1) {
              throw new Error("Unable to find next text");
            }
            this.string = this.string.substring(0, nextIndex);
          }
          if ((_ref = this.next.type) === 'node' || _ref === 'emptynode' || _ref === 'comment' || _ref === 'null') {
            nextOffset = 1;
          }
        } else {
          this.string = "";
        }
        this.strOffset += this.string.length;
        if (!this.nodeMatches('next', this.next, nextOffset)) {
          throw new Error("Unable to match section end");
        }
      };

      EscapedVariable.prototype.update = function(text) {
        var after, before, node, oldStr;
        node = this.node();
        if (node == null) {
          if (!(this.prev.type === 'null' && this.next.type === 'null')) {
            throw new Error("Unable to update, node must exist to begin with");
          }
          this.parent.appendChild(document.createTextNode(''));
          console.log('Creating text element, this is not a sound thing to do without an existing one');
          node = this.node();
        }
        oldStr = node.data;
        before = oldStr.substring(0, this.strStart);
        after = oldStr.substring(this.strOffset);
        node.data = before + text + after;
        this.string = text;
        return this.strOffset = before.length + this.string.length;
      };

      EscapedVariable.prototype.getRoot = function() {
        var obj, parent, parentNode;
        parent = parentNode = this.parent;
        if (parent.nodeType === 2) {
          parentNode = parent.ownerElement;
        }
        obj = {
          type: 'escaped',
          value: this.string,
          update: this.update,
          parent: parent,
          parentNode: parentNode
        };
        return obj;
      };

      EscapedVariable.prototype.getValues = function(merge) {
        if (merge != null) {
          if (!(merge instanceof Array)) {
            merge = [merge];
          }
          merge.push(this.getRoot());
        } else {
          merge = this.getRoot();
        }
        return merge;
      };

      return EscapedVariable;

    })(Mustache);
  });

}).call(this);
