// Generated by CoffeeScript 1.4.0
(function() {

  define([], function() {
    'use strict';

    var Mustache;
    return Mustache = (function() {

      function Mustache() {
        this.initialize.apply(this, arguments);
        this.parse();
      }

      Mustache.prototype.initialize = function(id, spec, partials, rootNode, nodeOffset, strOffset) {
        var i, index, offset, prop, skipRange, type, val, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results, _results1;
        this.id = id;
        this.spec = spec;
        this.partials = partials;
        this.rootNode = rootNode;
        this.nodeOffset = nodeOffset != null ? nodeOffset : 0;
        this.strOffset = strOffset != null ? strOffset : 0;
        _ref = this.spec[this.id];
        for (prop in _ref) {
          val = _ref[prop];
          this[prop] = val;
        }
        if (this.spec.verbose) {
          type = this.type;
          if (type === 'section' && this.inverted) {
            type = 'inverted section';
          }
          console.log("Construct " + type + ": '" + this.name + "' (" + this.id + ")", "nodeOffset:", this.nodeOffset, "strOffset:", this.strOffset);
        }
        this.parent = this.rootNode;
        _ref1 = this.path;
        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
          index = _ref1[i];
          if (!(i > 0)) {
            continue;
          }
          if (typeof index === 'number') {
            if (this.strOffset !== 0) {
              skipRange = (function() {
                _results = [];
                for (var _j = 0; 0 <= index ? _j <= index : _j >= index; 0 <= index ? _j++ : _j--){ _results.push(_j); }
                return _results;
              }).apply(this);
              if (i === this.path.length - 1 && ((_ref2 = this.prev.type) === 'section' || _ref2 === 'escaped' || _ref2 === 'text')) {
                skipRange = (function() {
                  _results1 = [];
                  for (var _k = 0, _ref3 = index - 1; 0 <= _ref3 ? _k <= _ref3 : _k >= _ref3; 0 <= _ref3 ? _k++ : _k--){ _results1.push(_k); }
                  return _results1;
                }).apply(this);
              }
              for (_l = 0, _len1 = skipRange.length; _l < _len1; _l++) {
                offset = skipRange[_l];
                if (!((_ref4 = this.node(offset).nodeType) === 1 || _ref4 === 8)) {
                  continue;
                }
                this.strOffset = 0;
                break;
              }
            }
            this.nodeOffset += index;
          }
          if (i === this.path.length - 1) {
            break;
          }
          switch (typeof index) {
            case 'number':
              this.parent = this.node();
              break;
            case 'string':
              this.parent = this.parent.attributes.getNamedItem(index);
          }
          this.nodeOffset = 0;
        }
        if ((_ref5 = this.prev.type) !== 'null') {
          this.nodeOffset -= 1;
        }
        if (this.prev.type === 'null') {
          if (this.nodeOffset !== 0) {
            throw new Error("Did not expect to find a previous node");
          }
        } else {
          if (!this.nodeMatches('prev', this.prev)) {
            throw new Error("The previous node did not match the expected value");
          }
        }
        if (this.prev.type === 'text') {
          this.strOffset += this.prev.value.length;
        }
        return this.strStart = this.strOffset;
      };

      Mustache.prototype.parse = function() {};

      Mustache.prototype.nodeMatches = function(name, match, offset) {
        var inverted, matched, node, result, _ref;
        if (offset == null) {
          offset = 0;
        }
        result = this.matchNode(match, offset);
        if (this.spec.verbose) {
          node = this.node(offset);
          if ((_ref = node != null ? node.nodeType : void 0) === 3 || _ref === 8) {
            node = (node.data.substring(0, this.strOffset)) + '|' + node.data.substring(this.strOffset);
          }
          inverted = '';
          if (this.inverted) {
            inverted = 'inverted ';
          }
          matched = 'Rejected';
          if (result) {
            matched = 'Matched';
          }
          console.log("" + matched + " " + name + " node of " + inverted + this.type + " '" + this.name + "'", {
            node: node,
            nodeOffset: this.nodeOffset + offset,
            strOffset: this.strOffset,
            offset: offset
          }, "to", match);
        }
        return result;
      };

      Mustache.prototype.matchNode = function(match, offset) {
        var current, node, _ref;
        if (offset == null) {
          offset = 0;
        }
        if (this.parent == null) {
          throw new Error("Cannot match node, @parent is undefined!");
        }
        if (offset !== 0) {
          current = this.node();
          if (current == null) {
            throw new Error("Tried to get offset " + offset + " when current node is undefined already");
          }
          if (offset > 0 && current.nodeType === 3 && current.data.length !== this.strOffset) {
            return false;
          }
          if (offset < 0 && this.strOffset > 0) {
            throw new Error("Request to compare previous node, but strOffset is not 0");
          }
        }
        node = this.node(offset);
        if (node == null) {
          if (match.type !== 'null') {
            return false;
          }
        }
        switch (match.type) {
          case 'section':
            throw new Error("Unsupported matching type");
            break;
          case 'partial':
            throw new Error("Unsupported matching type");
            break;
          case 'escaped':
            throw new Error("Unsupported matching type");
            break;
          case 'unescaped':
            throw new Error("Unsupported matching type");
            break;
          case 'node':
          case 'emptynode':
            return node.nodeType === 1 && node.tagName === match.name.toUpperCase();
          case 'comment':
            return node.nodeType === 8;
          case 'text':
            return ((_ref = node.nodeType) === 3 || _ref === 8) && node.data.substring(this.strOffset).indexOf(match.value) === 0;
          case 'null':
            return !(node != null);
        }
      };

      Mustache.prototype.node = function(offset) {
        if (offset == null) {
          offset = 0;
        }
        offset += this.nodeOffset;
        switch (this.parent.nodeType) {
          case 1:
          case 2:
            return this.parent.childNodes[offset];
          case 3:
            throw new Error("Attempted to access childNodes from text node");
            break;
          case 8:
            if (offset > 0) {
              throw new Error("Attempted to get offset > 0 from comment node");
            }
            return this.parent;
        }
      };

      return Mustache;

    })();
  });

}).call(this);
