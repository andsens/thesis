% !TEX root = thesis.tex
\chapter{Second iteration - Implementation}
\label{chap:impl}

In this chapter we will walk through the implementation of the pre-parsing tool
and the client library. We begin by detailing the process of parsing
mustache templates.

\section{Parsing mustache templates}
\todo{Think of a reason for haskell other than "I wanted to try it"}

Our language of choice for implementing the parser is Haskell.
We utilize the Parsec parser combinator library to analyze our mustache
templates. With Parsec we can convert an EBNF grammar very effortlessly
into Haskell code by using the combinators and parsers the library supplies
us with.

\subsection{Mustache EBNF}
The EBNF for mustache is fairly simple and can be seen in figure
\ref{fig:mustache.ebnf}.
The behavior of \inline{set\_delimiter} tag is ignored in this EBNF.

\begin{figure}
	\centering
	\caption{Mustache EBNF}
	\label{fig:mustache.ebnf}
	\setlength{\grammarindent}{3.5cm}
	\begin{grammar}
<variable> ::= `{{{' <ident> `}}}' | `{{&' <ident> `}}' | `{{' <ident> `}}'

<section> ::= `{{#' <ident> `}}' <content>* `{{/' <ident> `}}'
         \alt `{{^' <ident> `}}' <content>* `{{/' <ident> `}}'

<partial> ::= `{{>' <ident> `}}'

<comment> ::= `{{!' <comment> `}}'

<set\_delimiter> ::= `{{=' <delim\_start>  ' ' <delim\_end> `=}}'

<tag\_or\_char> ::= <section>
               \alt <partial>
               \alt <comment>
               \alt <set\_delimiter>
               \alt <variable>
               \alt <char>

<content> ::= <tag\_or\_char>*
	\end{grammar}
\end{figure}

\subsection{Mustache-XML EBNF}
We want our parser to not only be able to understand mustache grammar, but also
HTML grammar intermingled with it.

There are many flavors of HTML we may choose from to allow in our
mustache-HTML grammar. To simplify our approach we will only allow well
structured XML tags, this should ostensibly cover most of HTML.
HTML 5 allows for self-closing tags on void elements, which with our choice is
not something we can support.

We will build an abstract syntax tree with Parsec, in order for our tool to be
able to create DOM paths through this tree. The EBNF in figure
\ref{fig:mustache-xml.ebnf} represents the structure of the parser in our tool.

\begin{figure}
	\centering
	\caption{Mustache-XML EBNF}
	\label{fig:mustache-xml.ebnf}
	\setlength{\grammarindent}{4.2cm}
	\begin{grammar}
<variable> ::= `{{{' <ident> `}}}' | `{{&' <ident> `}}' | `{{' <ident> `}}'

<partial> ::= `{{>' <ident> `}}'

<content\_section> ::= `{{#' <ident> `}}' <template\_content>* `{{/' <ident> `}}'
                  \alt `{{^' <ident> `}}' <template\_content>* `{{/' <ident> `}}'

<attribute\_section> ::= `{{#' <ident> `}}' <attribute\_content>* `{{/' <ident> `}}'
                    \alt `{{^' <ident> `}}' <attribute\_content>* `{{/' <ident> `}}'

<comment\_section> ::= `{{\#' <ident> `}}' <comment\_content>* `{{/' <ident> `}}'
                  \alt `{{^' <ident> `}}' <comment\_content>* `{{/' <ident> `}}'

<content\_mustache\_tag> ::= <content\_section> | <partial> | <comment> | <variable>

<attribute\_mustache\_tag> ::= <attribute\_section> | <partial> | <comment> | <variable>

<comment\_mustache\_tag> ::= <comment\_section> | <partial> | <comment> | <variable>

<attribute> ::= ` ' <ident> `=\"' <attribute\_content>* `\"' 

<xml\_tag> ::= `<' <ident> <attribute>* `>' <template\_content>* `</' <ident> `>'
          \alt `<' <ident> <attribute>* `/>'
          \alt `<!--' <comment\_content>* `-->'

<attribute\_content> ::= <attribute\_mustache\_tag> | <char\_without\_doublequote>

<comment\_content> ::= <comment\_mustache\_tag> | <char>

<template\_content> ::= <content\_mustache\_tag> | <xml\_tag> | <char>

<content> ::= <template\_content>*
	\end{grammar}
\end{figure}

The comment tag has been left out in this grammar, since it does not output any
content our client library can retrieve. We did also not include the
\inline{set\_delimiter} tag. This was mostly done to keep our first
implementation of the tool simple.

\subsubsection{Template constraints}
Note that the EBNF restricts the types of
templates our tool can parse.

\begin{itemize}
\item XML tags must be closed in the same in the same template and section
      as they are opened
\item Sections must adhere to the same structure as XML tags
\item Variables and section may not exist in the identifier part of an XML tag
      or attribute
\end{itemize}

These structural restrictions may not be something a user will run into very
often, but they give our client library very useful guarantees about the
rendered templates it passes.
If XML tags were to be opened outside the scope of a template
and closed in the template we are parsing,
there would be no way to determine the location of mustache tags in
that template without performing complicated cross-references with the template
that opened these tags.

\subsubsection{Character References}
The EBNF omits character references (e.g. \inline{\&nbsp;}, \inline{\&aring;}).
When those character references are accessed via the DOM in the browser they are
returned in their interpreted form. This forces our tool to also be able to
understand character references. To that end we simply scan any text we have
recognized between tags for ampersands, all characters from that point on until
a semicolon is found are passed to the \inline{lookupEntity} function available
in the TagSoup library (\todo{Ref to Text.HTML.TagSoup.Entity}).

\subsubsection{Lexeme token parsers}
Parsec can create token parsers given a configuration with definitions of
allowed operator letters, reserved operator names,
legal identifier letters and many other pieces of information
that are useful for parsing tokens in a language.
The token parsers returned by Parsec are lexeme token parsers.
These token parsers consume any whitespace that follow most tokens.
They also throw errors when tokens are followed by operator letters.

\subsubsection{Significant white spaces}
In the case of our template parser, the otherwise advantageous properties
of lexeme token parsers are not desirable.
White spaces in the beginning of an attribute value or after an XML tag can be
very significant.
We will need to be sure when a mustache variable begins and ends.
If that variable is surrounded only by white spaces, our tool will convey
data to the client, which details that there is in fact no white space.
Subsequently the client will assume the white spaces recognized in the
rendered template belong to the value of the variable.

\subsection{Alternative parsing strategies}
Instead of Parsec we could have chosen an existing parsing technology for XML
and simply extended it.

\subsubsection{HXT (Text.XML.HXT)}
Haskell XML Tools (HXT) is a very advanced XML parser utilizing, amongst other
Haskell concepts, arrows. It is intended for querying structures the
tool has already created by parsing the XML. Using it to discover the structure
of documents is not its main purpose. With this tool, we would have to create a
new structure on top of the existing HXT XML structure.

\subsubsection{XML (Text.XML.Light)}
XML is an easy-to-use XML library, which exports its data constructors.
This allows us to pattern match and use deconstruction assignments in our
functions.
Mustache tags would have to be recognized by inspecting all strings in the
structure we receive. Following that, we have to overlay the structure with
section beginnings and ends, variable locations etc.. These overlay techniques
would very quickly grow bigger than the 250 lines of code our Parsec parser
spans now.

\section{Mustache-XML DOM Paths}
\label{sec:paths}
The abstract syntax tree our parser generates bears some resemblance to the
Document Object Model available in the browser. There is however the addition of
mustache section nodes and mustache variable leafs.
Once the template is rendered, a mustache section will not be visible and the
contents of that section will be joined with the siblings of said section.
Similarly, mustache variables output text which will be joined with neighboring
text nodes. When constructing DOM paths this fact has to be taken into account.

\subsection{Lists of numbers as paths}
There are several ways to pinpoint a node in the DOM. CSS-selectors, XPaths and
DOM API-call chains among them. The first two methods are easily
readable and writable for humans, a feature we are not interested in, since our
tool is only to communicate with our client library.
We will instead use the third option: DOM API-call chains. However cumbersome
and counter-intuitive a method like this may seem in other scenarios, it is
in fact the optimal tool for our purposes: We are never interested in retrieving
more than a single DOM node; knowing where a section or a variable begins is our
only goal for paths.

All children of a node are ordered and can be addressed by numbers. This allows
us to drill down through the DOM to a specific node by iterating through a list
of numbers, descending one node generation with each iteration.

\subsubsection{Children and offsets}
Paths can be divided into two types which we will call children and offsets.

Offsets are mustache tags whose location is affected by the string length of a
previous variable value or by the amount of iterations of a previous section.

To determine their location we will have to know the value of these previous
tags first. These tags may of course also only be offsets, this chain continues
until we meet a parent section or the beginning of the template.
The last part in such a chain will always be a child instead of an offset.
Children are tags with locations in the template that are not affected by
the value of a previous tag.

When parsing a rendered template in the client library, we will want to parse
all children first and continue with offsets that depend on those children.

Figure \ref{fig:section.mustache} from chapter \ref{chap:tools}
illustrates the difference very well, once we add a last list element as
shown in figure \ref{fig:offsets.mustache}.

\begin{figure}
	\centering
	\caption{Offsets in templates}
	\label{fig:offsets.mustache}
	\begin{lstlisting}[language=HTML]
	<p>
		Hello {{nickname}},<br/>
		you have {{messagecount}} new messages:
	</p>
	<ul>
		{{#messages}}
		<li>{{subject}} from {{nickname}}</li>
		{{/messages}}
		<li>That's all {{realname}}</li>
	</ul>
	\end{lstlisting}
\end{figure}

The \inline{\{\{realname\}\}} variable can only be retrieved once we know how
many times the messages section has iterated (in this case we could also look
for the last \inline{<li>} element, this is however not an approach that is
easily generalized). The path for \inline{\{\{realname\}\}} would consist of
two numbers:
\begin{itemize}
\item The node index of the \inline{<li>} element measured from
      the closing tag of the \inline{\{\{\#messages\}\}} section.
      Also counting the text node between those tags, we arrive at \emph{1}
\item The node index of the \inline{\{\{realname\}\}} variable. Although this
      variable will be merged with the previous text, we still count it as a
      separate node. We will adjust for this way of counting child nodes in
      the client library. Here we also arrive at index \emph{1}
\end{itemize}

The only detail missing from our new path is the reference to the node we are
offsetting from. Assuming we number each mustache tag in the template we can
simply refer to it by that number and prepend it to our path.

Child paths are generated in much the same way. If we were to generate a path
for the \inline{\{\{subject\}\}} variable in the above template, we would
proceed in the exact same way as with the \inline{\{\{realname\}\}} variable,
the only difference being its classification as a child instead of an offset.
The advantage we gain by this classification is our ability to distinguish
whether a variable is located inside or outside the section.

\section{Variable boundaries}
Variables embedded in text nodes will be merged with the neighboring text nodes
once a template is rendered. To extract the original text, the client library
will have to know the exact length of the text before and after it. If two
variables are located in the same text node, this extraction strategy is no
longer possible. Instead we simply remember the text surrounding the variable.
Using this prefix text our client library can not only find the beginning of a
variable, but also verify the preceding text. The succeeding text will be
used as a delimiter, it marks the end of our variable.
Using this strategy we can parse an arbitrary number of variables in one text
node, provided a variable does not contain the text of the succeeding text.

\subsection{Other boundaries}
The previous and next nodes of a variable may also HTML or mustache tags.
In the case of an HTML tag, we will simply relay the name of the tag to the
client library. If the variable is the first or last node, the client library
will receive a special ``null node'' as the previous or next node respectively.

We will tackle the case of neighboring nodes being mustache tags in chapter
\ref{chap:eval}.

\section{Recognizing iterations}
To detect whether a section is skipped because its value is an empty
list or false, we let the client library know what the first child of the
section is.
This way we can detect if a section in a rendered template begins with the
first child node or its neighboring next node.

\subsection{Content list}
We accompany each section with a list of child node types. The client library
shall consult this list to determine the length of each iteration.
The length of an iteration is constant, if a section only contains normal
HTML tags as its children. Once we introduce mustache tags, this can change.
The length of a subsection will increase the length of a parent section, while
unescaped variables may do the same.
In order for us to still reliably determine said length, we also include
mustache tags in this content list. The client library may then recurse into
these tags to asses the impact they have had on the length of an iteration.
\todo{Eval: this can be done a lot easier}

\subsection{Lambda sections}
Lambda sections and normal mustache sections can not be distinguished.
For that reason we will simply treat them as sections when parsing templates.

\subsection{If-else constructs}
Sections which are intended as if-else constructs are similarly impossible to
distinguish from normal sections, which iterate over a list. We tackle this
issue by regarding all sections as iterative sections. We return a list of
entries, regardless of the original data structure that was fed in to the
template rendering engine.

\subsection{Joined nodes}



\subsection{Node offsets}
\todo{Scrap this subsection}
We will also save a rough overview of the children of the section.
This overview is a simple list of the type (tag, self-closing tag, comment
or text node) of each child. If a child is a mustache tag, this type will be the
id of that tag instead.
By consulting this list we can determine by how much we have to increase the
last index in our path (see section \ref{sec:paths}) to arrive at
the next iteration or end of a section.
After each iteration we run through said list and increment our node offset for
every node we encounter. We also reset our node offset to the node offset of
a mustache tag, if any is encountered. Once we 


Any mustache tags inside a section with a path classification of ``child'' will
be instantiated once per iteration.

\section{Outputting information}
The information we retrieve from our templates is communicated to the client
library by way of the JSON data format. We generate it by using the JSON library
available in the ``Hackage'' Haskell library database (Text.JSON).

JSON files may contain an array or an object at the top-level. We chose to use
an array, in which each entry describes a mustache tag. Referencing between
those tags functions by way of the index in said array.
We also prepend array with a ``root'' element. It is referred to by mustache
tags that are not located inside a section and are not offset in their location
by other mustache tags.


\todo{Difference between parser combinators and parser generators}
\todo{What about cabal, cmdargs?}

\section{Client library}

\subsection{Scoping}
\todo{Don't bother with scoping, let the user decide when a variable is actually scoped}

