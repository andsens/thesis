% !TEX root = thesis.tex
\chapter{Second iteration - Implementation}
\label{chap:impl}

In this chapter we will walk through the implementation of the pre-parsing tool
and the client library. We begin by detailing the process of parsing
mustache templates.

\section{Parsing mustache templates}
\todo{Think of a reason for haskell other than "I wanted to try it"}

Our language of choice for implementing the parser is Haskell.
We utilize the Parsec parser combinator library to analyze our mustache
templates. With Parsec we can convert an EBNF grammar very effortlessly
into Haskell code by using the combinators and parsers the library supplies
us with.

\subsection{Mustache EBNF}
The EBNF for mustache is fairly simple and can be seen in figure
\ref{fig:mustache.ebnf}.
The behavior of \inline{set\_delimiter} tag is ignored in this EBNF.

\begin{figure}
	\centering
	\caption{Mustache EBNF}
	\label{fig:mustache.ebnf}
	\setlength{\grammarindent}{3.5cm}
	\begin{grammar}
<variable> ::= `{{{' <ident> `}}}' | `{{&' <ident> `}}' | `{{' <ident> `}}'

<section> ::= `{{#' <ident> `}}' <content>* `{{/' <ident> `}}'
         \alt `{{^' <ident> `}}' <content>* `{{/' <ident> `}}'

<partial> ::= `{{>' <ident> `}}'

<comment> ::= `{{!' <comment> `}}'

<set\_delimiter> ::= `{{=' <delim\_start>  ' ' <delim\_end> `=}}'

<tag\_or\_char> ::= <section>
               \alt <partial>
               \alt <comment>
               \alt <set\_delimiter>
               \alt <variable>
               \alt <char>

<content> ::= <tag\_or\_char>*
	\end{grammar}
\end{figure}

\subsection{Mustache-XML EBNF}
We want our parser to not only be able to understand mustache grammar, but also
HTML grammar intermingled with it.

There are many flavors of HTML we may choose from to allow in our
mustache-HTML grammar. To simplify our approach we will only allow well
structured XML tags, this should ostensibly cover most of HTML.
HTML 5 allows for self-closing tags on void elements, which with our choice is
not something we can support.

We will build an abstract syntax tree with Parsec, in order for our tool to be
able to create DOM paths through this tree. The EBNF in figure
\ref{fig:mustache-xml.ebnf} represents the structure of the parser in our tool.

\begin{figure}
	\centering
	\caption{Mustache-XML EBNF}
	\label{fig:mustache-xml.ebnf}
	\setlength{\grammarindent}{4.2cm}
	\begin{grammar}
<variable> ::= `{{{' <ident> `}}}' | `{{&' <ident> `}}' | `{{' <ident> `}}'

<partial> ::= `{{>' <ident> `}}'

<content\_section> ::= `{{#' <ident> `}}' <template\_content>* `{{/' <ident> `}}'
                  \alt `{{^' <ident> `}}' <template\_content>* `{{/' <ident> `}}'

<attribute\_section> ::= `{{#' <ident> `}}' <attribute\_content>* `{{/' <ident> `}}'
                    \alt `{{^' <ident> `}}' <attribute\_content>* `{{/' <ident> `}}'

<comment\_section> ::= `{{\#' <ident> `}}' <comment\_content>* `{{/' <ident> `}}'
                  \alt `{{^' <ident> `}}' <comment\_content>* `{{/' <ident> `}}'

<content\_mustache\_tag> ::= <content\_section> | <partial> | <comment> | <variable>

<attribute\_mustache\_tag> ::= <attribute\_section> | <partial> | <comment> | <variable>

<comment\_mustache\_tag> ::= <comment\_section> | <partial> | <comment> | <variable>

<attribute> ::= ` ' <ident> `=\"' <attribute\_content>* `\"' 

<xml\_tag> ::= `<' <ident> <attribute>* `>' <template\_content>* `</' <ident> `>'
          \alt `<' <ident> <attribute>* `/>'
          \alt `<!--' <comment\_content>* `-->'

<attribute\_content> ::= <attribute\_mustache\_tag> | <char\_without\_doublequote>

<comment\_content> ::= <comment\_mustache\_tag> | <char>

<template\_content> ::= <content\_mustache\_tag> | <xml\_tag> | <char>

<content> ::= <template\_content>*
	\end{grammar}
\end{figure}

The comment tag has been left out in this grammar, since it does not output any
content our client library can retrieve. We did also not include the
\inline{set\_delimiter} tag. This was mostly done to keep our first
implementation of the tool simple.

\subsubsection{Template constraints}
Note that the EBNF restricts the types of
templates our tool can parse.

\begin{itemize}
\item XML tags must be closed in the same in the same template and section
      as they are opened
\item Sections must adhere to the same structure as XML tags
\item Variables and section may not exist in the identifier part of an XML tag
      or attribute
\end{itemize}

These structural restrictions may not be something a user will run into very
often, but they give our client library very useful guarantees about the
rendered templates it passes.
If XML tags were to be opened outside the scope of a template
and closed in the template we are parsing,
there would be no way to determine the location of mustache tags in
that template without performing complicated cross-references with the template
that opened these tags.

\subsubsection{Character References}
The EBNF omits character references (e.g. \inline{\&nbsp;}, \inline{\&aring;}).
When those character references are accessed via the DOM in the browser they are
returned in their interpreted form. This forces our tool to also be able to
understand character references. To that end we simply scan any text we have
recognized between tags for ampersands, all characters from that point on until
a semicolon is found are passed to the \inline{lookupEntity} function available
in the TagSoup library (\todo{Ref to Text.HTML.TagSoup.Entity}).

\subsubsection{Lexeme token parsers}
Parsec can create token parsers given a configuration with definitions of
allowed operator letters, reserved operator names,
legal identifier letters and many other pieces of information
that are useful for parsing tokens in a language.
The token parsers returned by Parsec are lexeme token parsers.
These token parsers consume any whitespace that follow most tokens.
They also throw errors when tokens are followed by operator letters.

\subsubsection{Significant white spaces}
In the case of our template parser, the otherwise advantageous properties
of lexeme token parsers are not desirable.
White spaces in the beginning of an attribute value or after an XML tag can be
very significant.
We will need to be sure when a mustache variable begins and ends.
If that variable is surrounded only by white spaces, our tool will convey
data to the client, which details that there is in fact no white space.
Subsequently the client will assume the white spaces recognized in the
rendered template belong to the value of the variable.

\subsection{Alternative parsing strategies}
Instead of Parsec we could have chosen an existing parsing technology for XML
and simply extended it.

\subsubsection{HXT (Text.XML.HXT)}
Haskell XML Tools (HXT) is a very advanced XML parser utilizing, amongst other
Haskell concepts, arrows. It is intended for querying structures the
tool has already created by parsing the XML. Using it to discover the structure
of documents is not its main purpose. With this tool, we would have to create a
new structure on top of the existing HXT XML structure.

\subsubsection{XML (Text.XML.Light)}
XML is an easy-to-use XML library, which exports its data constructors.
This allows us to pattern match and use deconstruction assignments in our
functions.
Mustache tags would have to be recognized by inspecting all strings in the
structure we receive. Following that, we have to overlay the structure with
section beginnings and ends, variable locations etc.. These overlay techniques
would very quickly grow bigger than the 250 lines of code our Parsec parser
spans now.

\section{Mustache-XML DOM Paths}
\label{sec:paths}
The abstract syntax tree our parser generates bears some resemblance to the
Document Object Model available in the browser. There is however the addition of
mustache section nodes and mustache variable leafs.
Once the template is rendered, a mustache section will not be visible and the
contents of that section will be joined with the siblings of said section.
Similarly, mustache variables output text which will be joined with neighboring
text nodes. When constructing DOM paths this fact has to be taken into account.

\subsection{Lists of numbers as paths}
There are several ways to pinpoint a node in the DOM. CSS-selectors, XPaths and
DOM API-call chains among them. The first two methods are easily
readable and writable for humans, a feature we are not interested in, since our
tool is only to communicate with our client library.
We will instead use the third option: DOM API-call chains. However cumbersome
and counter-intuitive a method like this may seem in other scenarios, it is
in fact the optimal tool for our purposes: We are never interested in retrieving
more than a single DOM node; knowing where a section or a variable begins is our
only goal for paths.

All children of a node are ordered and can be addressed by numbers. This allows
us to drill down through the DOM to a specific node by iterating through a list
of numbers, descending one node generation with each iteration.

\subsubsection{Children and offsets}
\label{sec:children-offsets}
Paths can be divided into two types which we will call children and offsets.

Offsets are mustache tags whose location is affected by the string length of a
previous variable value or by the amount of iterations of a previous section.

To determine their location we will have to know the value of these previous
tags first. These tags may of course also only be offsets, this chain continues
until we meet a parent section or the beginning of the template.
The last part in such a chain will always be a child instead of an offset.
Children are tags with locations in the template that are not affected by
the value of a previous tag.

When parsing a rendered template in the client library, we will want to parse
all children first and continue with offsets that depend on those children.

Figure \ref{fig:section.mustache} from chapter \ref{chap:tools}
illustrates the difference very well, once we add a last list element as
shown in figure \ref{fig:offsets.mustache}.

\begin{figure}
	\centering
	\caption{Offsets in templates}
	\label{fig:offsets.mustache}
	\begin{lstlisting}[language=HTML]
	<p>
		Hello {{nickname}},<br/>
		you have {{messagecount}} new messages:
	</p>
	<ul>
		{{#messages}}
		<li>{{subject}} from {{nickname}}</li>
		{{/messages}}
		<li>That's all {{realname}}</li>
	</ul>
	\end{lstlisting}
\end{figure}

The \inline{\{\{realname\}\}} variable can only be retrieved once we know how
many times the messages section has iterated (in this case we could also look
for the last \inline{<li>} element, this is however not an approach that is
easily generalized). The path for \inline{\{\{realname\}\}} would consist of
two numbers:
\begin{itemize}
\item The node index of the \inline{<li>} element measured from
      the closing tag of the \inline{\{\{\#messages\}\}} section.
      Also counting the text node between those tags, we arrive at \emph{1}
\item The node index of the \inline{\{\{realname\}\}} variable. Although this
      variable will be merged with the previous text, we still count it as a
      separate node. We will adjust for this way of counting child nodes in
      the client library. Here we also arrive at index \emph{1}
\end{itemize}

The only detail missing from our new path is the reference to the node we are
offsetting from. Assuming we number each mustache tag in the template we can
simply refer to it by that number and prepend it to our path.

Child paths are generated in much the same way. If we were to generate a path
for the \inline{\{\{subject\}\}} variable in the above template, we would
proceed in the exact same way as with the \inline{\{\{realname\}\}} variable,
the only difference being its classification as a child instead of an offset.
The advantage we gain by this classification is our ability to distinguish
whether a variable is located inside or outside the section.

\section{Variable boundaries}
Variables embedded in text nodes will be merged with the neighboring text nodes
once a template is rendered. To extract the original text, the client library
will have to know the exact length of the text before and after it. If two
variables are located in the same text node, this extraction strategy is no
longer possible. Instead we simply remember the text surrounding the variable.
Using this prefix text our client library can not only find the beginning of a
variable, but also verify the preceding text. The succeeding text will be
used as a delimiter, it marks the end of our variable.
Using this strategy we can parse an arbitrary number of variables in one text
node, provided a variable does not contain the text of the succeeding text.

\subsection{Other boundaries}
The previous and next nodes of a variable may also HTML or mustache tags.
In the case of an HTML tag, we will simply relay the name of the tag to the
client library. If the variable is the first or last node, the client library
will receive a special ``null node'' as the previous or next node respectively.

We will tackle the case of neighboring nodes being mustache tags in chapter
\ref{chap:eval}.

\section{Recognizing iterations}
To detect whether a section is skipped because its value is an empty
list or false, we let the client library know what the first child of the
section is.
This way we can detect if a section in a rendered template begins with the
first child node or its neighboring next node.

\subsection{Content list}
\label{sec:content-list}
We accompany each section with a list of child node types. The client library
shall consult this list to determine the length of each iteration.
The length of an iteration is constant, if a section only contains normal
HTML tags as its children. Once we introduce mustache tags, this can change.
The length of a subsection will increase the length of a parent section, while
unescaped variables may do the same.
In order for us to still reliably determine said length, we also include
mustache tags in this content list. The client library may then access
information about these tags to asses the impact they have had on the length of
an iteration.
\todo{Eval: this can be done a lot easier}

\subsection{Lambda sections}
Lambda sections and normal mustache sections can not be distinguished.
For that reason we will simply treat them as sections when parsing templates.

\subsection{If-else constructs}
Sections which are intended as if-else constructs are similarly impossible to
distinguish from normal sections, which iterate over a list. We tackle this
issue by regarding all sections as iterative sections. We return a list of
entries, regardless of the original data structure that was fed in to the
template rendering engine.

\subsection{Node offsets}
\todo{Scrap this subsection}
We will also save a rough overview of the children of the section.
This overview is a simple list of the type (tag, self-closing tag, comment
or text node) of each child. If a child is a mustache tag, this type will be the
id of that tag instead.
By consulting this list we can determine by how much we have to increase the
last index in our path (see section \ref{sec:paths}) to arrive at
the next iteration or end of a section.
After each iteration we run through said list and increment our node offset for
every node we encounter. We also reset our node offset to the node offset of
a mustache tag, if any is encountered. Once we 


Any mustache tags inside a section with a path classification of ``child'' will
be instantiated once per iteration.

\section{Outputting information}
\label{sec:output}
The information we retrieve from our templates is communicated to the client
library by way of the JSON data format. We generate it by using the JSON library
available in the ``Hackage'' Haskell library database (Text.JSON).

JSON files may contain an array or an object at the top-level. We chose to use
an array, in which each entry describes a mustache tag. Referencing between
those tags functions by way of the index in said array (this index is the same
number we prepend to the paths of tags, see section \ref{sec:children-offsets}).
We also prepend array with a ``root'' element. It is referred to by mustache
tags that are not located inside a section and are not offset in their location
by other mustache tags.


\todo{Difference between parser combinators and parser generators}
\todo{What about cabal, cmdargs?}

\section{Client library}

\subsection{Technology choices}

\subsubsection{CoffeeScript}
We use use CoffeeScript to program our client library. The language allows us to 
write expressions very tersely, where plain JavaScript would have required
verbose instructions. This helps us to overview more code at once.
CoffeeScript constructs like \inline{unless exp}, which translates to
\inline{if(!exp)}, also help highlight control flow in a better way
semantically.

\subsubsection{Asynchronous Module Definition}
Our client library uses the AMD-API to define its modules.

\subsection{Input}
The client library expects the user to hand it both the rendered template and
the template information our pre-parser tool outputs.
How this data is retrieved is not the concern of the library.
The rendered template is expected to already be in the DOM format.
Additionally it needs to be wrapped in a container node,
which is the actual node that is to be handed to the library.
The client library also expects the JSON data to already have been interpreted
and converted to JavaScript objects.

\subsection{Representing mustache tags}
Our architecture for representing mustache tags is a one-to-one representation
of the possibilities in mustache.
Each section object holds all of its iterations. The subsection of a section is
instantiated as many times as the parent section iterates. The same principle
holds for variables and partials.

\subsubsection{Offsets}
Through the whole process, we will maintain two pointers that identify our
progress in the rendered template:
\begin{itemize}
\item \inline{nodeOffset}: Given a parent, this variable indicates the index
      in the \inline{childNodes} list we are currently pointing at (node offset).
\item \inline{strOffset}: Assuming the current node is a text node, this variable
      points at the current string position (string offset).
\end{itemize}

For all mustache tags, we will always keep a reference to the \inline{parent}
XML node it is located in. This allows us to increase and decrease the
\inline{nodeOffset} to access neighboring nodes. This would also be possible by
using the \inline{previousSibling} and \inline{nextSibling} properties,
mathematical operations like ``the 5th neighbor of the current node'' will
however grow more complicated.

The node offset and string offset is maintained separately for each mustache tag
object. An object is instantiated with those offsets, giving it a position to
follow its path from and find its node.

\subsubsection{Following DOM paths}
Given the position (\inline{nodeOffset}, \inline{strOffset} and \inline{parent})
of a mustache tag, we locate other mustache tags that have their location
specified relative to it by executing the following steps for each entry in
their respective path array
excluding the first entry, which is a mustache tag reference
(see section \ref{sec:children-offsets}):
\begin{itemize}
\item Add the current entry to the \inline{nodeOffset}
\item Break, if this is the last entry
\item Set the parent node to the childNode index \inline{nodeOffset} of the
      current parent node
\end{itemize}
We break in step 2 to let the parent point at the parent of the mustache tag
instead of the tag it has been replaced with.

If an entry in the iteration is a string instead of an integer, this indicates
an attribute name. In that case we set the parent node to be the attribute node
which supports the childNodes property as well.

\subsection{Parsing sections}
The parsing of sections constitutes the heart of operations in our library.
We bootstrap our parser by initializing the fake root section
(see \ref{sec:output}) with the template container node as its parent.
This method allows us to create a recursive parsing process which we will
initiate once per iteration for each section we encounter inside a section.

Inside an iteration we will also instantiate variables and partials that are
children of the current section. Any mustache tag located inside a subsection
will be handled by that section.

We begin by instantiating all mustache tags that are not offsets. Since these
tags have their location described relative to our section, we can find their
nodes immediately. Note that we in each section iteration adjust the node offset
to point at the node before the first node in the current iteration.
This ensures that the path following process works correctly.

Next we instantiate all tags that are offset by a preceding mustache tag.
Since our tool outputs information about tags in the order they appear in, in the
template, we simply iterate through the mustache tags, knowing we will not
encounter a tag with an offset pointing at a yet uninstantiated node.

\todo{We actually don't need to instantiate all children first, because of tpl ordering}

Once all tags in a section are instantiated and saved in an object mapped by
their identifier, we determine the length of our section with the content list
as described in section \ref{sec:content-list}. This length is used to adjust
the section node offset. Using it, mustache tags basing their path on this
section can locate their node.

Depending on whether the node following the current node can be identified as
a first child of the section or as a neighboring node, we either begin another
iteration or terminate the parsing process for this section.

\subsection{Joined nodes}
\label{sec:joined}

\subsection{Verifying nodes}

\todo{joined nodes}

\subsection{Scoping}
\todo{Don't bother with scoping, let the user decide when a variable is actually scoped}

