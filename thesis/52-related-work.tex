% !TEX root = thesis.tex
\documentclass[thesis.tex]{subfiles} 
\begin{document}

\chapter{Related Work}


\section{Similar goals}
In this section we will discuss a tool and a framework which in their goals
can be viewed as similar to Comb.

\subsection{Template::Extract}
Template::Extract\cite{TPLEXTRACT} is a tool written in perl module with a
functionality much like Comb. It is written for the ``Template Toolkit''
templating language and allows the developer to extract values from a rendered
template when given the template.
This extraction is accomplished by compiling a regular expression based on the
template and applying it to the rendered template.

\begin{citequote}{\cite{TPLEXTRACT}}
Extraction is done by transforming the result from Template::Parser to a highly
esoteric regular expression, which utilizes the (?\{...\}) construct to insert
matched parameters into the hash reference.
\end{citequote}

Our revised goal exactly matches Template::Extract, Comb however operates on the
Document Object Model while Template::Extract operates on a single string.
In \ref{chap:arch} we evaluated that strategy but discovered that the strings
returned by the \inline{innerHTML} property of DOM elements differ between
browsers and do not reflect the original rendered template.
By choosing to extracting values from the DOM we also gain the added advantage
of retaining references to the nodes the strings were extracted from\footnote{
	as detailed in \ref{sec:parent-nodes}
}.
This additional piece of information allows Comb to become more than a simple
value extraction library. The emergent properties discussed in
\ref{sec:emergent} and the potential additional layers Comb supports
differentiate Comb from the sole purpose of extracting data from templates.

\subsection{Rivet.js}
On the other side of the spectrum we have Rivet.js\footnote{
\url{http://rivetsjs.com/}}, which is a framework that
can bind templates written in plain HTML to Model frameworks like
backbone.js\footnote{\ref{sec:backbonejs}}. Changes in the Model will be
mirrored in the rendered template and vice-versa.
As such this framework is in its features very similar to the original goal we
formulated in chapter \ref{chap:requirements}.

However, rivet.js uses its own templating language to achieve this goal.
The rendering takes place when the models are bound to the template.
This precludes any form of server-side rendering without node.js\footnote{
\ref{sec:nodejs}}. In fact, rendering a template on the server-side and
transmitting it to the client is not possible without losing the bond between
DOM and Model.

Rivet.js is however an example of how a two-way binding layer\footnote{
As discussed in \ref{sec:two-way-binding}} for Comb may function.



\section{Similar domain}
In this section we will discuss papers which touch upon the same domain as Comb.

\subsection{MAWL}
Mawl\cite{MAWL} is a framework and domain-specific language developed in 1999
to aid the handling of HTML forms as well as telephone forms.
It does this by supplying the developer with a framework which compiles
a set of MAWL templates and ``sessions'' to executables
the browser can communicate with via the CGI on the web server.

The primary goal behind MAWL is to empower the developer with a better
organization of the data flow in form-based services.
This goal is achieved by creating a form abstraction language in which the
semantics of forms can be specified while the presentation layer of these forms
is handled by MAWL templates (MHTML).
CGI programs handling the data flow need no longer be programmed in
perl, Tcl or the Korn Shell, but can be compiled from said language.

A secondary advantageous property of MAWL is its ability to verify the
type signature of the form abstraction against structure of an MHTML template.
Although the paper does not go into detail explaining how these templates are
analyzed a parallel can be drawn to our Comb pre-parser tool which employs
Parsec to construct an abstract syntax tree. Much like MHTML is checked for
consistency, our parser also verifies mustache templates and displays any
possible errors\footnote{See \ref{sec:emergent}}.
\begin{citequote}{\cite{MAWL}}
First, the sessions and the MHTML can be independently analyzed to ensure that
they are internally consistent.
For the sessions, this means standard type checking and semantics checking.
For MHTML templates, this means verifying that a template is legal MHTML.
\end{citequote}

\subsection{Paper by Elsman et al.}
``Typing XHTML Web Applications in ML''\cite{ML} is a paper by Martin Elsman and
Ken Friis Larsen describing a system with which XHTML documents can be created,
whose conformity is guaranteed by the type system. The library is based on the
typed combinator library from Standard ML.

The second contribution in this paper is a system for interfacing scriptlets
with the data submitted by forms generated using the library.
It ensures consistency between the form generation and its retrieval.

\subsection{Frameworks vs. Tools}
A framework can be defined as an underlying structure, on which software can be
built. Using proven paths they guide the developer in creating applications to
increase efficiency and the probability of a satisfiable outcome.
Frameworks are usually comprised of not only a structure but a set of tools that
are deeply interconnected.

The frameworks in the two aforementioned papers can be describe as such, because
they supply the developer with a predefined set of tools that work together to
enable him to achieve a goal. The assurance that the templates are created in a
specific fashion allow them to ease the development of other parts of the
application\footnote{In both cases this would be the HTML forms}. Rivet.js can
also be categorized as a framework using the same argument.

Tools on the other hand do not dictate a predefined structure and only supply
the developer with a specific output given an input. They need not be versatile
in their capabilities to be good tools. Their reduced set of requirements for
performing makes them applicable in more than one situation. Because of their
simplicity a developer can use a tool in situations it may not have been
intended for and still produce a satisfying output. A tool is an extension of
the wielders capabilities rather than a recipe written by a master chef.

In this light we can classify Comb as a tool. It does not require the developer
to write in any new specially designed template language and dictates no
structure the developer has to follow. In \ref{sec:emergent} we even speculated
about unintended use-cases for Comb. Comb extends capabilities by supplying the
developer\footnote{...or additional layers as described in \ref{sec:asses-mdb}}
with information about templates and their rendered version.
How this information is used is not the concern of the tool.

\subsection{All or nothing}
Frameworks such as MAWL, the typed templates in ML, Dynamic Web
Documents \cite{DYNDOC} for JWIG or WASH \cite{wash} use an all-or-nothing
approach when it comes to typing templates and extracting additional information
from them.
Comb does not operate in the exact same domain as those frameworks, but it
stands to reason that the applicability of our tool is greater because of its
framework agnosticism.

The highly advantageous guarantees these frameworks supply may fall on deaf ears
when they require developers to switch to an unfamiliar framework or even to
a new server-side programming language. It is not possible to simply extract a
part of these frameworks and easily integrate it into another application
context.

This fact --- which can hardly be described as a shortcoming, since it is an
integral part of these frameworks uniqueness --- is what allows Comb to stand
apart. The template language is not one specifically designed for our purpose,
we simply latch on to an already successful project that has been ported to many
languages. Through this ubiquity Comb gains a higher chance of adoption as well.


\section{External DSL tools}


\end{document}
