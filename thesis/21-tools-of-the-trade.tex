% !TEX root = thesis.tex
\documentclass[thesis.tex]{subfiles} 
\begin{document}

\chapter{Tools of the Trade}
\label{chap:tools}
In order to achieve a separation of responsibility various frameworks and tools
are at a developers disposal. In this thesis we will focus on two of them
specifically.
\section{Client frameworks}
\subsection{Backbone.js}
\subsubsection{underscore.js}
prototype.js is a library developed by Sam Stephenson to improve upon the
DOM API itself.
It brought with it various improvements to native JavaScript prototype objects.
underscore.js carries these improvements into the world of jQuery.
It includes a small templating engine which will allow us to generate
DOM elements and insert them into the page.
\subsection{XPath}
XPath is a language that allows us to define a path from a root node to another
node. Although limited, the language is fairly concise and directly built into
JavaScript. We will only be dealing with XPath 1.0, because version 2.0 is, with
the exception of Microsoft Internet Explorer, not implemented in any browsers
yet and likely will not ever be (the final specification was released 2006).
\section{Templating languages}
A templating language allows the developer to create HTML documents containing
placeholders, which later can be filled by a Model and its attributes.
Templating is part of the "View" component in the Model-View-Controller
pattern. In the following we will have a look at one such templating language.

\subsection{Mustache}
Mustache is a so called "logic-less" template engine.
This subtitle derives from the fact that there are no advanced control flow
statements. Instead there are only tags.
Tags in this context can be understood as an advanced form of placeholders.
Some tags are replaced with a string, some are replaced with HTML tags,
yet others repeat their content multiple times.
Tags are easily recognizable by their delimiters which always start and end with
two curly braces (e.g. \inline{\{\{identifier\}\}}).

To render a mustache template, the template in conjunction with an
identifier mapping (i.e. the dataset) is passed to the engine, which returns the
rendered template.

\subsubsection{Variables}
\label{sect:mustache-vars}
Variables in mustache are string placeholders. We can recognize them by their
two curly braces before and after an identifier (\inline{\{\{identifier\}\}}).
The template engine replaces these tags with the corresponding value in the
dataset.
The identifier in the tag points at a key in the dataset with the same name.
Normal variables are HTML escaped. The engine outputs an empty string if the
key is not specified in the dataset.

An identifier may also point at properties on objects in the dataset. Like many
other languages the '.' character is used to access those properties (e.g. \inline{\{\{object.field\}\}}).

\subsubsection{Unescaped variables}
To output strings as unescaped HTML, triple curly braces are used:
\inline{\{\{\{identifier\}\}\}}. Alternatively an ampersand may be used as well:
\inline{\{\{\&identifier\}\}}.

\subsubsection{Sections}
Sections in mustache can be considered equivalent to foreach loops in other
languages. We write them with an open and close tag:
\inline{\{\{\#identifier\}\}CONTENT\{\{/identifier\}\}}.
Depending on the dataset value the identifier points at, a section may also be
behave like an if-block, which is rendered if the value is true. The values that
are considered true and false depend on the language specific implementation
of the engine.
\begin{citequote}{\cite[sections.yml]{MSTSPEC}}
	If the data is not of a list type, it is coerced into a list as follows: if
	the data is truthy (e.g. `!!data == true`), use a single-element list
	containing the data, otherwise use an empty list.
\end{citequote}
If the value is a list, the content of the section is rendered once for each
entry in the list. Once a section is entered, the key-value pairs of the
corresponding entry are pushed onto the stack of identifiers\footnote{
	This is called the ``context stack''
}.\
Consider the example in figures \ref{fig:section-example}.

\begin{figure}
	\centering
	\caption{An example of a mustache section}
	\label{fig:section-example}
	\begin{subfigure}{\textwidth}
		\begin{lstlisting}[language=JSON]
{ nickname: "andsens"
  messagecount: 2
  messages: [
  	{subject: "How did the presentation go?",
  	 nickname: "carl"},
  	{subject: "Welcome to Messageservice Inc.",
  	 nickname: "Messageservice Inc."}
  ]
}
		\end{lstlisting}
		\caption{Dataset}
		\label{fig:section-example.json}
	\end{subfigure}
	
	\begin{subfigure}{\textwidth}
		\begin{lstlisting}[language=mustache]
<p>
	Hello {{nickname}},<br/>
	you have {{messagecount}} new messages:
</p>
<ul>
	{{\#messages}}
	<li>{{subject}} from {{nickname}}</li>
	{{/messages}}
</ul>
		\end{lstlisting}
		\caption{Template}
		\label{fig:section-example.mustache}
	\end{subfigure}
	
	\begin{subfigure}{\textwidth}
		\begin{lstlisting}[language=HTML]
<p>
	Hello andsens,<br/>
	you have 2 new messages:
</p>
<ul>
	<li>How did the presentation go? from carl</li>
	<li>Welcome to Messageservice Inc. from Messageservice Inc.</li>
</ul>
		\end{lstlisting}
		\caption{Result}
		\label{fig:section-example.html}
	\end{subfigure}
\end{figure}
Here the placeholder "nickname" is used in two different contexts.
The first usage occurs while the context stack is only one level high.
The second usage occurs inside a section. Here the "nickname" identifier refers
to the "nickname" key of the corresponding dataset entry in the list of messages.
If we were to insert a \inline{\{\{messagecount\}\}} tag inside the section,
the output would be "2" for every iteration.

Mustache\footnote{excluding mustache.js, which may have some implementation
problems, see \url{https://github.com/janl/mustache.js/issues/185}} also allows
the current item in a list iteration to be referenced with a special ``dot''
operator, as can be seen in figure \ref{fig:dot-oper-example}.
\begin{figure}
	\centering
	\caption{Mustache template using the ``.'' variable}
	\label{fig:dot-oper-example}
	\begin{subfigure}{\textwidth}
		\begin{lstlisting}[language=JSON]
["How did the presentation go? from carl",
"Welcome to Messageservice Inc. from Messageservice Inc."]
		\end{lstlisting}
		\caption{Dataset}
		\label{fig:dot-oper-example.json}
	\end{subfigure}
	
	\begin{subfigure}{\textwidth}
		\begin{lstlisting}[language=mustache]
<ul>
	{{#messages}}
	<li>{{.}}</li>
	{{/messages}}
</ul>
		\end{lstlisting}
		\caption{Template}
		\label{fig:dot-oper-example.mustache}
	\end{subfigure}
	
	\begin{subfigure}{\textwidth}
		\begin{lstlisting}[language=HTML]
<ul>
	<li>How did the presentation go? from carl</li>
	<li>Welcome to Messageservice Inc. from Messageservice Inc.</li>
</ul>
		\end{lstlisting}
		\caption{Result}
		\label{fig:dot-oper-example.html}
	\end{subfigure}
\end{figure}

\subsubsection{Inverted sections}
In case a value in the dataset is an empty list or false, we use an inverted
section to output fallback content. We simply replace the hash-mark in the
opening tag of a section with a caret (see figure \ref{fig:inverted.mustache}).
\begin{figure}
	\centering
	\begin{lstlisting}[language=mustache]
{{#messages}}
<li>{{subject}} from {{nickname}}</li>
{{/messages}}
{{^messages}}
<li>You have no messages</li>
{{/messages}}
	\end{lstlisting}
	\caption{Inverted sections in mustache templates}
	\label{fig:inverted.mustache}
\end{figure}

We can exploit this behavior to create equivalents of if-else blocks.
Using the above template we can allow users to leave the subject line empty
and display a message accordingly, figure \ref{fig:ifelse.mustache} illustrates
this method.
\begin{figure}
	\centering
	\begin{lstlisting}[language=mustache]
<li>
	{{#subject}}{{subject}}{{/subject}}
	{{^subject}}(No subject){{/subject}}
	from {{nickname}}
</li>
	\end{lstlisting}
	\caption{If-else constructs with sections in mustache templates}
	\label{fig:ifelse.mustache}
\end{figure}

We can also access the message subject by using \inline{\{\{.\}\}},
since values that are not lists are converted into lists by mustache\footnote{
	The subject will be coerced into a list containing the subject string as its
	first and only entry.
}. Figure \ref{fig:dot-oper2.mustache} illustrates this shortcut.

\begin{figure}
	\centering
	\begin{lstlisting}[language=mustache]
<li>
	{{#subject}}{{.}}{{/subject}}
	{{^subject}}(No subject){{/subject}}
	from {{nickname}}
</li>
	\end{lstlisting}
	\caption{Using the dot variable on strings}
	\label{fig:dot-oper2.mustache}
\end{figure}

As mentioned earlier, variables are replaced with empty strings if
they do not correspond to an entry in the dataset.
This fact allows us to shorten the template even further as can be seen in
figure \ref{fig:emptystr.mustache}.
We do not need to check if a variable is not the empty string before outputting
it. The effect of outputting it regardless of its content is the same.

\begin{figure}
	\centering
	\begin{lstlisting}[language=mustache]
<li>
	{{subject}}{{^subject}}(No subject){{/subject}}
	from {{nickname}}
</li>
	\end{lstlisting}
	\caption{Variables output empty strings in mustache, if there is no values in the dataset for them}
	\label{fig:emptystr.mustache}
\end{figure}

\subsubsection{Lambdas}
Mustache tags identified by the hash mark may also represent another form of
placeholder namely the lambda sections. These sections are not iterations, but
calls to functions that have been bound to keys in the dataset.
The functions are called with the contents of section as their parameter, the
output of a lambda section is the return value of the function call.
In figure \ref{fig:lambda-example} we have bound a function to convert a
unix epoch time stamp into a relative date\footnote{... or an approximation of that}
to the key ``reldate''.

\begin{figure}
	\centering
	\caption{An example of lambda sections in mustache templates}
	\label{fig:lambda-example}
	\begin{subfigure}{\textwidth}
		\begin{lstlisting}[language=JSON]
{ reldate: function(text) {
  	return 'some time ago';
  },
  messages: [
  	{ subject: "How did the presentation go?",
  	  nickname: "carl",
  	  sent: 1355328898 },
  	{ subject: "A disturbance in the force, I felt...",
  	  nickname: "Yoda",
  	  sent: 513136200}
  ]
}
		\end{lstlisting}
		\caption{Data}
		\label{fig:lambda-example.data}
	\end{subfigure}
	
	\begin{subfigure}{\textwidth}
		\begin{lstlisting}[language=mustache]
<ul>
	{{#messages}}
	<li>{{subject}} from {{nickname}} sent {{#reldate}}{{sent}}{{/reldate}}</li>
	{{/messages}}
</ul>
		\end{lstlisting}
		\caption{Template}
		\label{fig:lambda-example.mustache}
	\end{subfigure}
	
	\begin{subfigure}{\textwidth}
		\begin{lstlisting}[language=HTML]
<ul>
	<li>How did the presentation go? from carl sent some time ago</li>
	<li>A disturbance in the force, I felt... from Yoda sent some time ago</li>
</ul>
		\end{lstlisting}
		\caption{Result}
		\label{fig:lambda-example.html}
	\end{subfigure}
\end{figure}

\subsubsection{Comments}
A comment in mustache is identified by an exclamation mark:
\inline{\{\{! This is a comment \}\}}
The comment tag creates no output.

\subsubsection{Partials}
Partials allow templates to be split up into smaller parts. Their tags are
replaced with the contents of other templates. They behave as if the referenced
template was inlined directly at the location of the partial tag.
The contents of the partial templates have to be passed to the rendering engine
together with the main template and the dataset.

The inlining happens when a template is rendered. This enables mustache to
render recursive data-structures. For example the template in figure
\ref{fig:partial-example} will render a directory structure using nested lists.

\begin{figure}
	\centering
	\caption{Mustache templates can be recursive by utilizing partial tags}
	\label{fig:partial-example}
	\begin{subfigure}{\textwidth}
		\begin{lstlisting}[language=JSON]
{ directories: [{
		name: "bin",
		direcories: []
		files: ["echo", "ls"]
	},
	{
		name: "usr",
		direcories: [{
			name:"local"
			files: ["notes.txt", "donotopen.jpg"]
		}],
		files: ["randomfile.bin"]
	}]
}
		\end{lstlisting}
		\caption{Data}
		\label{fig:partial-example.data}
	\end{subfigure}
	
	\begin{subfigure}{\textwidth}
		\begin{lstlisting}[language=mustache]
<ul>
	{{#directories}}
	<li>{{name}}/ {{>filesystem}}</li>
	{{/directories}}
	{{#files}}
	<li>{{.}}</li>
	{{/files}}
</ul>
		\end{lstlisting}
		\caption{Template, the partial named ``filesystem'' points at this template}
		\label{fig:partial-example.mustache}
	\end{subfigure}
	
	\begin{subfigure}{\textwidth}
		\begin{lstlisting}[language=HTML]
<ul>
	<li>bin/:
		<ul>
			<li>echo</li>
			<li>ls</li>
		</ul>
	</li>
	<li>usr/:
		<ul>
			<li>local/:
				<ul>
					<li>notes.txt</li>
					<li>donotopen.jpg</li>
				</ul>
			</li>
			<li>randomfile.bin</li>
		</ul>
	</li>
</ul>
		\end{lstlisting}
		\caption{Resulting filesystem list\footnote{The indentations may be incorrect}}
		\label{fig:partial-example.html}
	\end{subfigure}
\end{figure}

\subsubsection{Set delimiter}
Mustache curly braces may clash with delmiters used in other languages,
such as LaTeX. Using the "set delimiter" tag, the delimiter can be changed to
something else. The equals sign is used to signify a change in delimiters.
In figure \ref{fig:set-delim.mustache}, we change the delimiters
to PHP tags, write some text using the now inactive mustache tags and enable the
normal mustache tags again.

\begin{figure}
	\centering
	\begin{lstlisting}[language=HTML]
Subject: {{subject}}
{{=<? ?>=}}
Nickname: <?nickname?>
Curly braces (and text): {{ This will be normal text enclosed by curly braces }}
<?={{ }}=?>
No output: {{undefined_variable}}
PHP tags: PHP begins with "<?" and ends with "?>"
	\end{lstlisting}
	\caption{Usage of set delimiter tags in mustache templates}
	\label{fig:set-delim.mustache}
\end{figure}

\subsubsection{Removal of standalone lines}
\label{sec:standalone-lines}
Mustache removes lines which beyond a section beginning or end contains
only white space (i.e. standalone lines).
This is done to match the expectation a user may have when writing templates.
The behavior is however not defined clearly:
\begin{citequote}{\cite[sections.yml]{MSTSPEC}}
	Section and End Section tags SHOULD be treated as standalone when
	appropriate. 
\end{citequote}

\subsubsection{Mustache specification}
Documents specifying the exact behavior of mustache can be viewed at
\url{https://github.com/mustache/spec}. The specification is written in YAML to
allow automated tests of rendering engines.

\subsection{Limitations}
\todo{fix entire paragraph}
These templating languages are very different in their design.
All aim to improve one or more aspects of the templating task.
Of those Mustache seems to be specifically tailored for web applications
with interactive JavaScript parts.
They all have a common trait which in some cases can be an advantage
but given any specific implementation of a web application is a drawback:
They are completely oblivious of their surroundings. They draw the line
at the "View" part in order to encourage a separation from the other
parts. This comes at the cost of lost information when sending a
rendered view to the client.


\end{document}
