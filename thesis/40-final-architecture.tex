\chapter{Final Architecture}

Our goal is to create a tool that allows the user to pass a rendered template
(DOM) to it and receive a data structure that equates
the original data passed to the template engine.
Parsing can be a process that requires a lot of processing power. We do not want
our tool to slow down the web application every time a new template is rendered
and the values are retrieved on the client. To minimize the effort required to
parse a rendered template we try to compile as much information as possible
about a template before it is rendered. Using this information we should be able
to parse a rendered template more quickly.
This strategy implies a pre-parsing step that outputs data which aids
the client library in parsing a rendered template. Since this is an operation
that only needs to be run before a web application is deployed, we are not
constrained by the environment the actual web server runs in.

\section{Compiling template information}
The data that is required for the client library to run, we need
to be able to parse a mustache template and acquire the necessary information
from it.
Analyzing a mustache template we can deduce the following pieces of information
before the template is rendered.

\begin{itemize}
\item The location of variables in the document
\item Whether a variable is escaped or unescaped
        (\inline{\{\{identifier\}\}} vs. \inline{\{\{\{identifier\}\}\}})
\item The location of sections in the document
\item Whether a section is inverted
        (\inline{\{\{#identifier\}\}} vs. \inline{\{\{^identifier\}\}})
\item The contents of a section
\item The location of partials in the document
\item The location of comments in the document
\end{itemize}

Because of the nature of templates we can however not retrieve the following data:

\begin{itemize}
\item The contents of variables
\item The number of iterations a section will run
\item Whether a section is a loop or an if block
        (except in the case of an inverted section)
\item The template a partial points at
\end{itemize}

The rendered template is in the Document Object Model format, once it has
been rendered by the client. We can still access the rendered template as a
string after it has been inserted by accessing the \inline{innerHTML} property
on the element node it was inserted into. This has one major drawback however.
The browser does not return the actual string that was inserted but rather a
serialized version of the DOM. This is demonstrated quite easily by executing
the following lines in the Google Chrome Developer Console:
\begin{lstlisting}[language=HTML]
var div = document.createElement("div")
div.innerHTML = "<img/>"
div.innerHTML
\end{lstlisting}

The last line does not return the string "<img/>" but "<img>" instead.
In Firefox the last line returns "<img xmlns="http://www.w3.org/1999/xhtml" />".
This means that the rendered templates can not be parsed reliably by using the
\inline{innerHTML} property.

However, no matter which way the browser decides to represent an HTML tag,
we can still rely on the tag names to be the same
(case sensitivity can be avoided with a simple
\inline{element.tagName.toLowerCase()} when comparing tag names client side).
We therefore opt to relate the information about mustache tags to the DOM instead.

This choice requires our pre-parsing tool to be able to understand
HTML documents and construct a DOM resembling structure in which the
mustache tags can be located and their location converted into a DOM path.

\section{Mustache}

\section{Overview}
\subsection{Parsing templates}

\begin{itemize}
\item Use haskell with parsec
\item Generate information for the client
\item Architecture for retrieval of that information
\item Client library to put that information to use and retrieve values
\end{itemize}

\section{Strategy for retrieving values}
\begin{itemize}
\item Minimize scope (only loops and variables, no partials)
\item Always treat sections as loops. Even if they are if blocks
\item Recognize sections and variables by boundaries (inner \& outer)
\item Create JSON objects containing enough information for the client library to retrieve values
\item Don't bother with scoping, let the user decide when a variable is actually scoped
\end{itemize}

\section{Challenges}
\begin{itemize}
\item Unescaped variables can wreak havoc
\item Ambiguities can occur between two boundaries
\item TextNodes that are separate in the parser are merged on the client
\end{itemize}
