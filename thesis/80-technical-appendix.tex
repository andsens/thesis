% !TEX root = thesis.tex
\documentclass[thesis.tex]{subfiles} 
\begin{document}

\appendix
\chapter{Technical Appendix}
\section{Choosing the tools}
Existing frameworks supply much of the functionality we require.
\begin{itemize}
\item requirejs to get the information about placeholder locations to the client.
\item as in the prototype: backbone to represent client models,
	collections and views
\item chaplin to supply us with a framework. Chaplin is very lightweight and
	utilizes backbone. It comes with controllers and extended views and adds
	collectionviews
\item handlebars is a port of mustache templates to the client side
\item coffeescript to avoid all the javascript nonsense
\item HaXML to parse html templates
\item Parsec to combine HaXML and a custom parser for mustache templates
\end{itemize}



\section{php-activerecord}
\label{sec:php-activerecord}
\todo{write}

\section{CoffeeScript}
\label{sec:coffeescript}
\todo{write}

\section{Bootstrap}
\label{sec:bootstrap}
\todo{write}

\section{require.js}
\label{sec:requirejs}
\todo{write}

\section{chaplin}
\label{sec:chaplin}

Chaplin is a new client side framework, which was created in February 2012.
The motivation behind it was to create a framework that allows developers to
follow a set of conventions more easily. Backbone.js has both views and models
(and routes, for controllers), but does not force any specific way of
structuring code. In this respect Backbone.js can be seen more as a tool than a
framework.
Chaplin extends the models and views from Backbone.js and adds more features.
It introduces concepts such as ``subviews'' - views that aggregate other views.
This allows the developer among other things to better mirror the structure of
the DOM.

The framework also allows the developer to use any template engine he desires.
The engine simply needs to return an object, which jQuery can append to the
wrapping DOM element of the view.

A very useful feature of Chaplin is the automatic memory management.
When creating single page web-applications, the developer has to dispose each
view manually. This challenge is best illustrated with regard to event handlers.
Event handlers are functions, that are called when an event on a DOM node or
an other object is triggered. Often this function manipulates and accesses
properties stored on a view. To allow for this access, the function stores a
pointer to the view via a closure. Since the function is stored with the
DOM node or object on which it is listening for events, any view the developer
wants to dispose needs to stop listening on those events as well.
Chaplin unbinds these event handlers for the developer when the view is
disposed, allowing the browser to free up memory.

\section{Movie Database \#2}

\subsection{Tools and frameworks}
\label{sec:mdb2-tools}
\todo{write}
\todo{ref to above tools}
require.js, chaplin, mustache, jquery
composer, php-activerecord, mustache, rest framework

\end{document}
